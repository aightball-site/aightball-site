<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AIght Ball – Voice Model Test</title>
  <title>AIght Ball – Narrative Forecast</title>
  <style>
    :root{
      --bg:#0d0d0d; --fg:#f2f2f2; --muted:#bbbbbb; --card:#111; --border:#333;
      --accent:#33cc99; --accent-hover:#2ab386;
      /* keep existing accent palette for borders */
      --driver:#2dd4bf; --planner:#f2c94c; --probe:#7aa0b4; --sage:#a78bfa;
      --ink:#04110d;
    }
@@ -66,6 +67,7 @@
    .odds{ margin-left:auto; font-weight:900; font-size:.95rem; color:#cfcfcf; }
    .body{ margin:0; color:#e6e6e6; line-height:1.5; white-space:pre-wrap; }

    /* keep existing border color hooks */
    .card--driver{ border-color:rgba(45,212,191,.35); }
    .card--planner{ border-color:rgba(242,201,76,.35); }
    .card--probe{ border-color:rgba(122,160,180,.35); }
@@ -125,12 +127,13 @@
const shakeBtn = document.getElementById('shake-btn');
const responsesEl = document.getElementById('responses');

/* ================== VOICES ================== */
const VOICES = [
  { id:'driver', label:'Driver', badge:'Direct', color:'var(--driver)' },
  { id:'planner', label:'Planner', badge:'Plan', color:'var(--planner)' },
  { id:'probe', label:'Inquisitive', badge:'Probe', color:'var(--probe)' },
  { id:'sage', label:'Sage', badge:'Muse', color:'var(--sage)' },
/* ================== OUTCOME TIERS (Unified Voice) ================== */
// We keep four cards for layout parity, but they're narrative outcome tiers, not personas.
const TIERS = [
  { id:'common',   label:'Likely',     badge:'Main Path',   color:'var(--driver)',   cardClass:'card--driver'   },
  { id:'uncommon', label:'Alternate',  badge:'Second Path', color:'var(--planner)',  cardClass:'card--planner'  },
  { id:'rare',     label:'Long Shot',  badge:'Third Path',  color:'var(--probe)',    cardClass:'card--probe'    },
  { id:'xfactor',  label:'Wildcard',   badge:'X-Factor',    color:'var(--sage)',     cardClass:'card--sage'     },
];

/* ================== UTIL ================== */
@@ -139,24 +142,23 @@
function seededHash(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,16777619); } return h>>>0; }
function nowBucket(minutes=60){ return Math.floor(Date.now()/1000/60/minutes); }
function clamp(n,a=0,b=1){ return Math.min(b, Math.max(a,n)); }
function cardClass(id){ return id==='driver'?'card--driver':id==='planner'?'card--planner':id==='probe'?'card--probe':'card--sage'; }

function renderSkeletons(){
  responsesEl.innerHTML = '';
  VOICES.forEach(v=>{
  TIERS.forEach(t=>{
    const div = document.createElement('div');
    div.className = `persona-card skeleton ${cardClass(v.id)}`;
    div.className = `persona-card skeleton ${t.cardClass}`;
    div.innerHTML = `
      <div class="head"><span class="pill role">${v.label}</span><span class="pill" style="opacity:.75">Generating…</span></div>
      <div class="head"><span class="pill role">${t.label}</span><span class="pill" style="opacity:.75">Generating…</span></div>
      <div class="line wide"></div><div class="line med"></div><div class="line short"></div>
    `;
    responsesEl.appendChild(div);
  });
}

function createCard({voice, label, badge, pct, text, onClick}){
function createCard({tier, label, badge, pct, text, onClick}){
  const div = document.createElement('div');
  div.className = `persona-card ${cardClass(voice)}`;
  div.className = `persona-card ${tier.cardClass}`;
  const pctStr = (typeof pct === 'number') ? `${pct}%` : '—';
  div.innerHTML = `
    <div class="head">
@@ -207,12 +209,14 @@
  const art = ARTIFACT_POOLS[topic]||ARTIFACT_POOLS.general;
  return {
    artifact: art[seed % art.length],
    window: ['tonight','tomorrow','this weekend','next week','by lunch','by Monday'][ (seed>>>3)%6 ]
    window: ['tonight','tomorrow','this weekend','next week','by lunch','by Monday'][ (seed>>>3)%6 ],
    tempo: ['steady cadence','short sprints','slow build','weekend push','late-night focus'][ (seed>>>6)%5 ]
  };
}

/* ================== PROBABILITY MODEL (voice-specific) ================== */
function baseYes(q, topic){
/* ================== PROBABILITY MODEL (Unified) ================== */
function baseTilt(q, topic){
  // Similar to prior baseYes, but used as a directional prior for the main path.
  let b=50, s=q.toLowerCase();
  if (s.includes('should i')) b+=4;
  if (s.includes('now')||s.includes('today')) b+=2;
@@ -224,75 +228,66 @@
  const jitter = ((seededHash(q+topic) % 11) - 5);
  return Math.max(5, Math.min(95, b+jitter));
}
function voicePct(voice, base){
  // independent tilts per voice
  if (voice==='driver'){
    let p = base + (base>=55? +8 : base<=45? -8 : 0);
    return Math.round(clamp(p/100, .3, .9)*100);
  }
  if (voice==='planner'){
    let p = base + (base>=60? +4 : base<=55? -6 : 0);
    // center to 35–65
    p = Math.max(35, Math.min(65, p));
    return Math.round(p);
  }
  if (voice==='probe'){
    // sometimes omit % entirely; return null 40% of time
    if ((seededHash(String(base)) % 10) < 4) return null;
    let p = base + ((seededHash('p'+base)%21)-10); // ±10 wobble
    return Math.max(20, Math.min(80, Math.round(p)));
  }
  // sage
  {
    let p = base;
    if (base>=70) p+=6; else if (base>=40 && base<=60) p-=5; // leans wait in ambiguity
    return Math.max(40, Math.min(70, Math.round(p)));
  }

function allocateProbabilities(q, topic){
  const base = baseTilt(q, topic); // 0-100
  const seed = seededHash(q);
  // Primary between 55–75 if base>50, else 45–60; keep realistic spread
  const main = base>=50
    ? Math.min(80, Math.max(55, base + ((seed%13)-6)))
    : Math.max(40, Math.min(60, base + ((seed%9)-4)));

  // Secondary 20–35, influenced inversely by main
  const alt = Math.max(15, Math.min(35, 100 - main - (seed%15)));

  // Rare gets 5–15, remainder goes to xfactor
  let rare = Math.max(5, Math.min(15, (seed%11)+5));
  let x = Math.max(0, 100 - Math.round(main) - Math.round(alt) - Math.round(rare));

  // Occasionally suppress X-factor to 0 for cleaner 3-path read
  if ((seed%7)===0){ x = 0; rare += Math.min(5, 100 - (Math.round(main)+Math.round(alt)+Math.round(rare))); }

  return {
    common:   Math.round(main),
    uncommon: Math.round(alt),
    rare:     Math.round(rare),
    xfactor:  Math.round(x)
  };
}
function leanFromPct(voice, pct, base){
  if (voice==='probe' && pct==null) return 'mixed';
  const p = pct;
  if (p>=65) return 'yes';
  if (p<=40) return 'no';
  if (p>40 && p<55) return 'wait';
  return 'mixed';

/* ================== NARRATIVE COPY (Unified Voice) ================== */
function sceneBits(topic){
  const places = {
    work:['inbox ping','desk lamp','whiteboard edge','calendar chime','Slack sidebar'],
    relationship:['doorway pause','hands warming a mug','sidewalk corner','open tab left unsent','quiet room'],
    food:['warm pan','grocery aisle','steam from a bowl','recipe margin','timer beep'],
    health:['shoelace knot','cold water glass','stretch in the doorway','sunlight on the floor','heartbeat settling'],
    money:['budget cell turning green','order summary','checkout button hover','account alert','transfer note'],
    creative:['cursor blink','scrap of melody','thumbnail draft','scene card','margin doodle'],
    travel:['open booking tab','packed duffel','printed route','gate display','weather check'],
    tech:['toggle in settings','progress bar','backup prompt','commit message','patch notes'],
    philosophy:['journal margin','breath count','window reflection','page fold','late-night hush'],
    general:['open tab','sticky note','quiet hallway','phone buzz','evening light']
  };
  return places[topic]||places.general;
}

/* ================== COPY RULES ================== */
function driverText(pct, topic, seed, q){
  const tb = timebox(topic), A = seed.artifact, W = seed.window;
  const softened = pct<60;
  if (softened){
    return `Move if it still feels right. Use the ${A} to start one obvious slice for ${tb}. Stop on a clean save and reassess ${W}.`;
  }
  return `Act now. Open the ${A}, push the main slice for ${tb}, and cut extras. Save on progress, quit, and pick up ${W}.`;
function commonText(pct, topic, seed, q){
  const tb = timebox(topic), A=seed.artifact, bits = sceneBits(topic);
  return `Most paths lead here (${pct}%). You open the ${A}, set a ${tb} window, and the first win arrives sooner than your doubt expects — a ${randFrom(bits, seededHash(q))} that signals you’re on the right thread. Keep the tempo ${seed.tempo}; end one step early so tomorrow has a runway.`;
}
function plannerText(pct, topic, seed, q){
  const tb = timebox(topic), A = seed.artifact, W = seed.window;
  const conditionalStart = (seededHash(q) % 2)===0;
  const open = conditionalStart ? `If you move forward, map first.` : `Map before moving.`;
  const constraint = `Cap the effort at ${tb} with one checkpoint at halfway.`;
  const finish = `Log a line in the ${A} and review ${W}.`;
  return `${open} Break it into a single step, ${constraint} ${finish}`;
function uncommonText(pct, topic, seed, q){
  const A=seed.artifact, bits = sceneBits(topic);
  return `The alternate arc (${pct}%) starts with friction. A detail doesn’t click — a ${randFrom(bits, seededHash('u'+q))} you can’t ignore. You pivot once, trim scope in the ${A}, and the story slows without stalling. It still lands, just later than you planned.`;
}
function probeText(topic, seed, q){
  const tb = timebox(topic), A = seed.artifact, W = seed.window;
  const q1 = `What exactly are you hoping will change if you do this?`;
  const q2 = `What would staying put teach you that moving wouldn’t?`;
  const step = `Try one tiny experiment for ${tb} and write one line in the ${A}; if it warms, schedule time ${W}.`;
  return `${q1} ${q2} ${step}`;
function rareText(pct, topic, seed, q){
  const bits = sceneBits(topic);
  return `The long shot (${pct}%) snaps into place when chance intervenes — a stranger’s note, a lucky timing window, or a ${randFrom(bits, seededHash('r'+q))} that becomes the hinge. If it appears, drop what can wait and ride the break.`;
}
function sageText(pct, topic, seed, q){
  const W = seed.window;
  // single image budget
  const image = randFrom(['tide','glimmer','quiet door','low hum','soft light'], seededHash(q));
  if (pct>=65){
    return `If the ${image} is steady, begin—and end a step early. Let attention stay soft, not forced. Return ${W} with the echo still warm.`;
  }
  if (pct<=45){
    return `If the ${image} dims when you think of it, pause. Let the night be still; timing gathers when you stop tugging. Look again ${W}.`;
  }
  return `Stand at ease and listen. If the ${image} returns twice, that’s your signal; if it scatters, wait. Either way, notice the timing ${W}.`;
function xfactorText(pct, topic, seed, q){
  if (!pct || pct<=0) return `Dormant in this reading — no meaningful wildcards detected. If one arrives, it’ll announce itself loudly.`;
  const bits = sceneBits(topic);
  return `The wildcard (${pct}%) isn’t predictable, but it is usable. Expect an external jolt — a policy shift, an unexpected ally, or a ${randFrom(bits, seededHash('x'+q))}. Treat it as acceleration, not a new destination.`;
}

/* ============ DIVERSITY GUARD ============ */
@@ -306,7 +301,7 @@
  for(const s of usedSets){ for(const g of my){ if(s.has(g)) return false; } }
  return true;
}
function trimByLen(txt, min=60, max=260){
function trimByLen(txt, min=60, max=360){
  if (txt.length<=max) return txt;
  const cut = txt.lastIndexOf('.', max);
  return (cut>min ? txt.slice(0,cut+1) : txt.slice(0,max)).trim();
@@ -319,65 +314,60 @@
  if(on) renderSkeletons();
}

async function renderVoices(question){
async function renderForecast(question){
  setLoading(true);
  try{
    const topic = detectTopic(question);
    const seed = extractSeed(question, topic);
    const base = baseYes(question, topic);
    const pct = allocateProbabilities(question, topic);
    const used = [];
    responsesEl.innerHTML = '';

    // deterministic artifact cycling for regen variety
    const artPool = [...(ARTIFACT_POOLS[topic]||ARTIFACT_POOLS.general)];
    const artAt = (i)=> artPool[i % artPool.length];
    const tiersInOrder = ['common','uncommon','rare','xfactor'];

    VOICES.forEach((v, idx)=>{
    tiersInOrder.forEach((key, idx)=>{
      const t = TIERS.find(x=>x.id===key);
      const placeholder = document.createElement('div');
      placeholder.className = `persona-card skeleton ${cardClass(v.id)}`;
      placeholder.className = `persona-card skeleton ${t.cardClass}`;
      placeholder.innerHTML = `
        <div class="head"><span class="pill role">${v.label}</span><span class="pill" style="opacity:.75">Generating…</span></div>
        <div class="head"><span class="pill role">${t.label}</span><span class="pill" style="opacity:.75">Generating…</span></div>
        <div class="line wide"></div><div class="line med"></div><div class="line short"></div>
      `;
      responsesEl.appendChild(placeholder);

      (async()=>{
        // local synth (you can swap to backend by posting {voice, controls} here)
        const pct = voicePct(v.id, base);
        const localSeed = { artifact: artAt(idx), window: seed.window };

        let text =
          v.id==='driver' ? driverText(pct??base, topic, localSeed, question) :
          v.id==='planner' ? plannerText(pct??base, topic, localSeed, question) :
          v.id==='probe'   ? probeText(topic, localSeed, question) :
                             sageText(pct??base, topic, localSeed, question);

        // diversity guard
        const makeText = (tierKey)=>{
          const p = pct[tierKey];
          if (tierKey==='common')   return commonText(p, topic, seed, question);
          if (tierKey==='uncommon') return uncommonText(p, topic, seed, question);
          if (tierKey==='rare')     return rareText(p, topic, seed, question);
          return xfactorText(p, topic, seed, question);
        };

        let text = makeText(key);
        let tries=0;
        while(!distanceOk(text, used) && tries<2){
          text = text.replace(/\.$/,'') + (v.id==='probe' ? ' Note what surprised you.' : ' Make it one step smaller.');
          text = text.replace(/\.$/,'') + ' — tighten one more notch.';
          text = trimByLen(text);
          tries++;
        }
        used.push(ngrams(text,4));

        const card = createCard({
          voice: v.id,
          label: v.label,
          badge: v.badge,
          pct: (v.id==='probe'? null : pct),
          tier: t,
          label: t.label,
          badge: t.badge,
          pct: pct[key]>0? pct[key] : null,
          text,
          onClick: async ()=>{
            // regenerate this voice with rotated artifact
            const again = { artifact: artAt(idx+1), window: seed.window };
            const p2 = voicePct(v.id, base);
            let t2 =
              v.id==='driver' ? driverText(p2??base, topic, again, question) :
              v.id==='planner' ? plannerText(p2??base, topic, again, question) :
              v.id==='probe'   ? probeText(topic, again, question) :
                                 sageText(p2??base, topic, again, question);
            // regenerate with slight time/window remix for variety
            const remix = { ...seed, window: ['tonight','tomorrow','this weekend','next week','by lunch','by Monday'][ ((seededHash(key+Date.now())>>>3)%6) ] };
            let t2;
            if (key==='common')   t2 = commonText(pct[key], topic, remix, question);
            else if (key==='uncommon') t2 = uncommonText(pct[key], topic, remix, question);
            else if (key==='rare')     t2 = rareText(pct[key], topic, remix, question);
            else                        t2 = xfactorText(pct[key], topic, remix, question);
            card.querySelector('.body').textContent = t2;
            if (v.id!=='probe') card.querySelector('.odds').textContent = `${p2}%`;
          }
        });
        placeholder.replaceWith(card);
@@ -391,14 +381,16 @@
}

/* ================== EVENTS ================== */
document.getElementById('shake-btn').addEventListener('click', ()=>{
function askOrShake(){
  const q = inputEl.value.trim() || "Surprise me";
  renderVoices(q);
});
  renderForecast(q);
}

document.getElementById('shake-btn').addEventListener('click', askOrShake);

document.getElementById('question-form').addEventListener('submit', (e)=>{
  e.preventDefault();
  const q = inputEl.value.trim() || "Surprise me";
  renderVoices(q);
  askOrShake();
});
</script>
</body>























