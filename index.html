<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AIght Ball – Voice Model Test</title>
  <style>
    :root{
      --bg:#0d0d0d; --fg:#f2f2f2; --muted:#bbbbbb; --card:#111; --border:#333;
      --accent:#33cc99; --accent-hover:#2ab386;
      --driver:#2dd4bf; --planner:#f2c94c; --probe:#7aa0b4; --sage:#a78bfa;
      --ink:#04110d;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; font-family:Inter,system-ui,Arial,Helvetica,sans-serif;
      background:radial-gradient(1200px 800px at 50% -10%, #1a1a1a, var(--bg));
      color:var(--fg); min-height:100vh; display:grid;
      grid-template-rows:auto auto 1fr auto; align-items:start;
    }
    .hero{ display:grid; place-items:center; padding:2rem 1.25rem .5rem; }
    .hero img{ width:min(70vw,520px); max-height:45vh; object-fit:contain; border-radius:20px;
      box-shadow:0 30px 80px rgba(0,0,0,.5); user-select:none; -webkit-user-drag:none; }

    .demo{ margin:.5rem auto 0; padding:1.25rem 1.1rem 1.6rem; border:1px solid var(--border);
      border-radius:18px; width:min(92vw, 760px); background:linear-gradient(180deg,#121212,var(--card));
      box-shadow:0 24px 50px rgba(0,0,0,.35);
    }

    .oracle-wrap{ display:grid; place-items:center; margin-bottom:.75rem; }
    .eightball{ width:min(64vw,320px); height:min(64vw,320px); border-radius:50%;
      background:radial-gradient(circle at 35% 30%, #2b2b2b 0%, #111 55%, #000 100%);
      box-shadow:inset 0 -20px 40px rgba(0,0,0,.7), 0 30px 60px rgba(0,0,0,.45);
      display:grid; place-items:center; overflow:hidden; transition:transform .2s cubic-bezier(.2,.8,.2,1); }
    .eightball .window{ width:50%; height:50%; border-radius:50%; display:grid; place-items:center;
      background:radial-gradient(circle at 50% 40%, #0b1b27, #03121c 60%, #01090e 100%);
      border:2px solid #0f2a3a; box-shadow:inset 0 0 40px rgba(0,0,0,.9); }
    .window .triangle{ position:relative; width:0; height:0; border-left:80px solid transparent; border-right:80px solid transparent; border-top:120px solid #163a5a; filter:drop-shadow(0 6px 10px rgba(0,0,0,.6)); }
    .triangle .msg{ position:absolute; top:-82px; left:50%; transform:translateX(-50%);
      width:120px; text-align:center; font-weight:800; font-size:1.05rem; letter-spacing:.4px; color:#cde7ff; text-shadow:0 1px 0 rgba(0,0,0,.5); }

    .qa{ display:flex; gap:.5rem; flex-wrap:wrap; justify-content:center; margin:1rem 0 .4rem; }
    input[type="text"]{
      padding:.85rem .95rem; border:none; border-radius:10px; min-width:300px; background:#1a1a1a; color:#fff; outline:1px solid var(--border);
    }
    button{
      padding:.9rem 1.1rem; border:none; border-radius:12px; background:var(--accent); color:var(--ink); font-weight:800; cursor:pointer;
      transition:background .15s ease, transform .08s ease, box-shadow .15s ease; box-shadow:0 8px 18px rgba(51,204,153,.25);
    }
    button:hover{ background:var(--accent-hover); } button:active{ transform:translateY(1px); }
    .helper{ color:var(--muted); text-align:center; margin:.25rem 0 .75rem; }

    .responses-wrap{ border:1px solid var(--border); border-radius:14px; background:#121212; max-height:540px; overflow:auto; padding:.6rem; }
    .responses-grid{ display:grid; grid-template-columns:1fr; gap:.6rem; }
    @media(min-width:680px){ .responses-grid{ grid-template-columns:1fr 1fr; } }

    .persona-card{
      border:1px solid var(--border); border-radius:12px; padding:.85rem .95rem .95rem;
      background:linear-gradient(180deg, #141414, #0f0f0f);
      transition:transform .06s ease, box-shadow .15s ease, border-color .15s ease;
    }
    .persona-card:hover{ transform:translateY(-1px); box-shadow:0 8px 16px rgba(0,0,0,.25); }
    .head{ display:flex; align-items:center; gap:.5rem; margin:0 0 .35rem; }
    .pill{ display:inline-flex; align-items:center; gap:.35rem; font-weight:800; padding:.16rem .55rem; border-radius:999px; background:var(--accent); color:var(--ink); font-size:.78rem; text-transform:uppercase; letter-spacing:.3px; }
    .pill.role{ background:#222; color:#ddd; font-weight:700; }
    .odds{ margin-left:auto; font-weight:900; font-size:.95rem; color:#cfcfcf; }
    .body{ margin:0; color:#e6e6e6; line-height:1.5; white-space:pre-wrap; }

    .card--driver{ border-color:rgba(45,212,191,.35); }
    .card--planner{ border-color:rgba(242,201,76,.35); }
    .card--probe{ border-color:rgba(122,160,180,.35); }
    .card--sage{ border-color:rgba(167,139,250,.35); }

    .narrative{
      border:1px solid var(--border); border-radius:12px; padding:1rem;
      background:linear-gradient(180deg, #171717, #121212); color:#eaeaea; line-height:1.6;
    }
    .narrative h3{ margin:.2rem 0 .4rem; font-size:1.05rem; color:#d6d6d6; }

    .skeleton{ position:relative; overflow:hidden; }
    .skeleton .line{ height:12px; background:#1b1b1b; border-radius:6px; margin:.4rem 0; }
    .skeleton .line.wide{ width:92%; } .skeleton .line.med{ width:75%; } .skeleton .line.short{ width:55%; }
    .skeleton::after{ content:""; position:absolute; inset:0; background:linear-gradient(90deg, transparent, rgba(255,255,255,.06), transparent);
      animation:shimmer 1.2s infinite; }
    @keyframes shimmer{ 0%{transform:translateX(-100%);} 100%{transform:translateX(100%);} }

    footer{ margin:1.25rem 0 1.5rem; text-align:center; color:#8a8a8a; font-size:.95rem; }
    a{ color:var(--accent); text-decoration:none; } a:hover{ text-decoration:underline; }
    .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
    .shake{ animation:wobble .6s ease-in-out; } @keyframes wobble{
      0%{transform:rotate(0) translateX(0)}20%{transform:rotate(3deg) translateX(6px)}
      40%{transform:rotate(-3deg) translateX(-6px)}60%{transform:rotate(2deg) translateX(4px)}
      80%{transform:rotate(-2deg) translateX(-4px)}100%{transform:rotate(0) translateX(0)}}
  </style>
</head>
<body>
  <section class="hero" aria-label="AIght Ball">
    <img src="Images/Logo.jpg" alt="AIght Ball logo"/>
  </section>

  <section id="demo" class="demo" role="region" aria-label="AIght Ball demo">
    <div class="oracle-wrap">
      <div class="eightball" id="orb"><div class="window"><div class="triangle"><div class="msg" id="orb-msg">ASK A QUESTION</div></div></div></div>
    </div>

    <form id="question-form" class="qa" autocomplete="off">
      <label class="sr-only" for="user-question">Ask a question</label>
      <input id="user-question" type="text" name="question" placeholder="Ask anything—decisions, dilemmas, ideas…" maxlength="200"/>
      <button type="submit" aria-label="Ask AIght Ball">Ask</button>
      <button type="button" id="shake-btn" aria-label="Shake the ball">Shake It</button>
    </form>
    <p class="helper">Tip: press Enter to ask. Or just shake for a random reading.</p>

    <div class="responses-wrap" aria-live="polite">
      <div id="narrative" class="narrative" hidden>
        <h3>Story</h3>
        <div id="narrative-text"></div>
      </div>

      <div id="responses" class="responses-grid"></div>
    </div>
  </section>

  <footer>
    © 2025 AIght Ball · Follow us on
    <a href="https://instagram.com/aightball.io" target="_blank" rel="noopener">Instagram</a> &
    <a href="https://youtube.com/@aightballio" target="_blank" rel="noopener">YouTube</a>
  </footer>

<script>
/* ================== DOM HOOKS ================== */
const orb = document.getElementById('orb');
const orbMsg = document.getElementById('orb-msg');
const inputEl = document.getElementById('user-question');
const askBtn = document.querySelector('#question-form button[type="submit"]');
const shakeBtn = document.getElementById('shake-btn');
const responsesEl = document.getElementById('responses');
const narrativeBox = document.getElementById('narrative');
const narrativeText = document.getElementById('narrative-text');

/* ================== SINGLE SOURCE OF TRUTH ================== */
const state = {
  loading: false,
  question: "",
  narrative: "",
  fields: { probability:null, confidence:null, advice:"", caveats:"" }
};

/* ================== FIELD DEFINITIONS ================== */
const FIELDS = [
  { key:'probability', label:'Probability', badge:'Odds', card:'card--driver', fmt:v => (v==null? '—' : `${Math.round(v)}%`) },
  { key:'confidence',  label:'Confidence',  badge:'Certainty', card:'card--planner', fmt:v => (v==null? '—' : (typeof v==='number'? `${Math.round(v)}%` : String(v))) },
  { key:'advice',      label:'Advice',      badge:'Move', card:'card--probe', fmt:v => String(v||'') },
  { key:'caveats',     label:'Caveats',     badge:'Watch', card:'card--sage', fmt:v => String(v||'') },
];

/* ================== UTIL ================== */
function shakeOrb(){ orb.classList.remove('shake'); void orb.offsetWidth; orb.classList.add('shake'); }
function seededHash(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,16777619); } return h>>>0; }
function clamp(n,a=0,b=1){ return Math.min(b, Math.max(a,n)); }

function renderSkeletons(){
  narrativeBox.hidden = false;
  narrativeText.innerHTML = `<div class="skeleton">
    <div class="line wide"></div><div class="line wide"></div><div class="line med"></div>
  </div>`;
  responsesEl.innerHTML = '';
  FIELDS.forEach(f=>{
    const div = document.createElement('div');
    div.className = `persona-card skeleton ${f.card}`;
    div.innerHTML = `
      <div class="head"><span class="pill role">${f.label}</span><span class="pill" style="opacity:.75">Generating…</span></div>
      <div class="line wide"></div><div class="line med"></div><div class="line short"></div>
    `;
    responsesEl.appendChild(div);
  });
}

function createFieldCard(def, value){
  const div = document.createElement('div');
  div.className = `persona-card ${def.card}`;
  const headerRight = (def.key==='probability' || def.key==='confidence') ? `<span class="odds">${def.fmt(value)}</span>` : '';
  div.innerHTML = `
    <div class="head">
      <span class="pill role">${def.label}</span>
      <span class="pill">${def.badge}</span>
      ${headerRight}
    </div>
    <p class="body">${(def.key==='advice' || def.key==='caveats') ? def.fmt(value) : ''}</p>
  `;
  return div;
}

/* ============== CONTEXT-FIRST PROMPT COMPOSER ============== */
/* We keep your API, but nudge output into: natural paragraph + CHIPS line. */
function composePrompt(userQuestion){
  return `
You are AIght Ball: give a short, empathetic, *context-first* narrative that directly addresses the user's wording (not forced yes/no).

Write ONE compact paragraph (<= 110 words) that:
- mirrors the question's intent,
- gives orientation (move / wait / explore / reflect),
- includes one concrete next step and one caveat,
- feels specific to the question (echo key terms once).

After the paragraph, add a single metadata line starting with "CHIPS:" in this exact key/value format:
CHIPS: prob=0-100; conf=High|Medium|Low; move="one-sentence next step"; watch="one-sentence caveat"

Question: ${userQuestion}
`;
}

/* ================== PARSERS (non-intrusive) ================== */
/* 1) CHIPS parser (preferred) */
function parseChipsBlock(text){
  // Find CHIPS line anywhere near the end
  const chipsMatch = text.match(/CHIPS:\s*([^]+)$/i);
  if(!chipsMatch) return null;

  const before = text.slice(0, chipsMatch.index).trim();
  const chips = chipsMatch[1].trim();

  // key=value; pairs, values may be quoted
  const obj = {};
  chips.split(/;\s*/).forEach(pair=>{
    const m = pair.match(/(\w+)\s*=\s*("(?:[^"]+)"|[^;]+)/);
    if(m){
      const k = m[1].toLowerCase();
      let v = m[2]?.trim() ?? '';
      if (v.startsWith('"') && v.endsWith('"')) v = v.slice(1,-1);
      obj[k] = v;
    }
  });

  const probability = obj.prob ? Number(obj.prob) : (obj.probability ? Number(obj.probability) : null);
  const confidence = obj.conf || obj.confidence || null;
  const advice = obj.move || '';
  const caveats = obj.watch || obj.caveats || '';

  return {
    narrative: before,
    probability: Number.isFinite(probability) ? Math.max(0, Math.min(100, Math.round(probability))) : null,
    confidence: confidence || null,
    advice,
    caveats
  };
}

/* 2) Labeled fallback ("Verdict/Why/Move/Watch/PROB/CONF") */
function parseLabeled(text){
  const grab = (label)=> {
    const r = new RegExp(`^\\s*${label}\\s*:\\s*([^]+?)(?:\\n\\s*[A-Z]{2,}|$)`, 'im');
    const m = text.match(r);
    return m ? m[1].trim() : '';
  };
  const narrative = text.replace(/^(\s*(Verdict|Why|Move|Watch|PROB|CONF)\s*:.*)+/gim,'').trim() || text.trim();
  const probRaw = grab('PROB').replace('%','').trim();
  const conf = grab('CONF') || null;
  const advice = grab('Move');
  const caveats = grab('Watch') || grab('Caveats');
  const probability = probRaw ? Math.max(0, Math.min(100, Math.round(Number(probRaw)))) : null;

  return { narrative, probability, confidence: conf || null, advice, caveats };
}

/* Heuristic: if we have structured chips, use them; otherwise return null. */
function tryExtractFromText(text){
  const chips = parseChipsBlock(text);
  if (chips) return chips;
  // check for labels quickly
  if (/(^|\n)\s*(Verdict|Why|Move|Watch|PROB|CONF)\s*:/i.test(text)) {
    return parseLabeled(text);
  }
  return null;
}

/* ================== TOPIC & LOCAL SYNTH (unchanged fallback) ================== */
const ARTIFACT_POOLS = {
  work:['Slack DM','email draft','ticket','calendar block','deck slide'],
  relationship:['text message','voice note','coffee invite','note'],
  food:['pan','bowl','order ticket','recipe note'],
  health:['timer','water bottle','doctor note','walk route'],
  money:['budget line','cart','limit note','transfer'],
  creative:['script stub','thumbnail','draft file','outline'],
  travel:['booking tab','packing list','route card','note'],
  tech:['settings pane','backup','update list','repo'],
  philosophy:['journal line','sticky note','breath count'],
  general:['note','list','tab','timer']
};
function detectTopic(q){
  const s=q.toLowerCase(); const has=(...w)=>w.some(x=>s.includes(x));
  if (has('boss','promotion','raise','job','coworker','department','sabbatical','work','school','degree','career')) return 'work';
  if (has('invest','house','rent','car','laptop','loans','side hustle','interest','loan','warranty','crypto','budget')) return 'money';
  if (has('ex','friend','relationship','love','reunion','forgive','apologize','move in','partner','honest','peace')) return 'relationship';
  if (has('sick','gym','caffeine','therapy','breakfast','meditation','doctor','rest','social-media','cold','health')) return 'health';
  if (has('dinner','cook','order','vegetarian','groceries','meal','sugar','eat','fasting','coffee')) return 'food';
  if (has('trip','vacation','travel','ticket','flying','drive','camping','eclipse','abroad')) return 'travel';
  if (has('youtube','podcast','book','art','guitar','piano','streaming','workspace','creative','painting','poetry')) return 'creative';
  if (has('dream','passion','path','happiness','purpose','potential','control','balance','intuition')) return 'philosophy';
  if (has('tiktok','ai','phone','unplug','apps','linux','resume','budget tracking','pc')) return 'tech';
  return 'general';
}
function timebox(topic){
  return ({work:'25 minutes', food:'40 minutes', relationship:'15 minutes', health:'20 minutes', money:'10 minutes',
    creative:'30 minutes', travel:'20 minutes', tech:'15 minutes', philosophy:'10 minutes', general:'20 minutes'})[topic]||'20 minutes';
}
function localSynthesis(question){
  const topic = detectTopic(question);
  const seed = seededHash(question);
  const artPool = ARTIFACT_POOLS[topic]||ARTIFACT_POOLS.general;
  const artifact = artPool[seed % artPool.length];
  const window = ['tonight','tomorrow','this weekend','next week','by lunch','by Monday'][ (seed>>>3)%6 ];
  // base prob
  let base=50, s=question.toLowerCase();
  if (s.includes('should i')) base+=4;
  if (s.includes('now')||s.includes('today')) base+=2;
  if (/(quit|end|sell|delete|cut out)/.test(s)) base-=6;
  if (/(start|try|begin|learn)/.test(s)) base+=6;
  if (/(wait|later|too soon)/.test(s)) base-=4;
  const topicBias = {work:0, money:-2, relationship:-2, health:3, food:2, travel:1, creative:4, tech:0, philosophy:0, general:0}[topic]||0;
  base += topicBias + (((seed % 11) - 5));
  base = Math.max(5, Math.min(95, base));
  // narrative + fields
  const tb = timebox(topic);
  const narrative = `Here's how this lands: make one concrete move, not the whole thing. Open the ${artifact}, push a single slice for ${tb}, and stop on a clean save. Look again ${window}.`;
  const probability = Math.round(clamp(base/100,.1,.95)*100);
  const confidence = (probability>=70? 'High' : probability>=50? 'Medium' : 'Low');
  const advice = (probability>=65)
    ? `Act now. Keep it scoped to ${tb}. Cut extras; log one line in the ${artifact}.`
    : (probability<=40)
      ? `Hold. Sleep on it. If it still pulls ${window}, reassess with a smaller slice.`
      : `Try a reversible micro-step for ${tb}. Decide after you review ${window}.`;
  const caveats = `If money, safety, or relationships are at risk, add a second opinion before committing.`;
  return { narrative, probability, confidence, advice, caveats };
}

/* =============== API WRAPPER (PRESERVES YOUR FETCH) =============== */
/*
  If you already expose one of these functions on window, we’ll use it:
    - window.fetchAightBallDecision(prompt)
    - window.aightApiFetch(prompt)
    - window.callDecisionAPI(prompt)
  We pass a composed prompt to encourage the context-first narrative.
*/
async function fetchDecision(userPrompt){
  const composed = composePrompt(userPrompt);

  const cand = [
    window.fetchAightBallDecision,
    window.aightApiFetch,
    window.callDecisionAPI
  ].find(fn => typeof fn === 'function');

  if (cand){
    const raw = await cand(composed);
    return normalizeResult(raw, userPrompt);
  }
  // Fallback to local synth
  return localSynthesis(userPrompt);
}

/* Normalize responses without overriding existing good fields.
   If a long narrative/plain text is returned, try to extract CHIPS/labels. */
function normalizeResult(raw, userQuestion){
  // Non-object payload → treat as text
  if (!raw || (typeof raw !== 'object' && typeof raw !== 'string')){
    return localSynthesis(userQuestion);
  }

  // If backend returned a plain string
  if (typeof raw === 'string'){
    const parsed = tryExtractFromText(raw);
    return parsed || { ...localSynthesis(userQuestion), narrative: raw.trim() };
  }

  // Object payload: use provided fields first
  let n = raw.narrative || raw.story || raw.summary || raw.text || '';
  let prob = raw.probability ?? raw.odds ?? raw.percent ?? null;
  let conf = raw.confidence ?? raw.certainty ?? null;
  let advice = raw.advice ?? raw.recommendation ?? raw.action ?? '';
  let caveats = raw.caveats ?? raw.risks ?? raw.cons ?? raw.notes ?? '';

  // If narrative contains CHIPS/labels, parse and prefer those
  const parsed = n ? tryExtractFromText(n) : null;
  if (parsed){
    // Prefer explicit backend fields if present; otherwise parsed
    n = n ? parsed.narrative : parsed.narrative;
    prob = (prob==null ? parsed.probability : prob);
    conf = (conf==null ? parsed.confidence : conf);
    advice = advice || parsed.advice;
    caveats = caveats || parsed.caveats;
  }

  // If probability came as 0–1, map to %
  if (typeof prob === 'number' && prob <= 1) prob = Math.round(prob*100);

  // Final fill using local synth only for empty slots (non-invasive)
  if (!n || (!advice && !caveats && prob==null && !conf)){
    const synth = localSynthesis(userQuestion);
    n ||= synth.narrative;
    advice ||= synth.advice;
    caveats ||= synth.caveats;
    prob = (prob==null ? synth.probability : prob);
    conf ||= synth.confidence;
  }

  return {
    narrative: (n || '').trim(),
    probability: (typeof prob === 'number' ? Math.max(0, Math.min(100, Math.round(prob))) : null),
    confidence: conf || null,
    advice: advice || '',
    caveats: caveats || ''
  };
}

/* ================== RENDER LOOP ================== */
function setLoading(on){
  state.loading = on;
  askBtn.disabled = on; shakeBtn.disabled = on;
  orbMsg.textContent = on ? "…" : "ASK A QUESTION";
  if (on) renderSkeletons();
}

function render(){
  // narrative
  if (state.narrative){
    narrativeBox.hidden = false;
    narrativeText.textContent = state.narrative;
  } else {
    narrativeBox.hidden = true;
    narrativeText.textContent = '';
  }

  // fields
  responsesEl.innerHTML = '';
  FIELDS.forEach(def=>{
    const val = state.fields[def.key];
    const card = createFieldCard(def, val);
    responsesEl.appendChild(card);
  });
}

async function runQuery(q){
  setLoading(true);
  try{
    state.question = q;
    const result = await fetchDecision(q);
    state.narrative = result.narrative || '';
    state.fields = {
      probability: result.probability ?? null,
      confidence:  result.confidence ?? null,
      advice:      result.advice ?? '',
      caveats:     result.caveats ?? ''
    };
    shakeOrb();
  } catch(err){
    state.narrative = "Sorry—something went wrong. Try again or check your network/API key.";
    state.fields = { probability:null, confidence:null, advice:"", caveats:"" };
    console.error(err);
  } finally{
    setLoading(false);
    render();
  }
}

/* ================== EVENTS ================== */
document.getElementById('shake-btn').addEventListener('click', ()=>{
  const q = inputEl.value.trim() || "Surprise me";
  runQuery(q);
});
document.getElementById('question-form').addEventListener('submit', (e)=>{
  e.preventDefault();
  const q = inputEl.value.trim() || "Surprise me";
  runQuery(q);
});
</script>














































